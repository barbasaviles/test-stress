"use strict";
// TODO: start stack with [`language-${lang}`]
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.themes = exports.highlightFileSync = exports.highlightFile = exports.highlight = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const prismjs_1 = __importDefault(require("prismjs"));
const string_length_1 = __importDefault(require("string-length"));
// primary use is to highlight ts/js programs, call
// loadLanguages() to support others.
const index_js_1 = __importDefault(require("prismjs/components/index.js"));
(0, index_js_1.default)(['tsx', 'typescript', 'javascript', 'jsx']);
const parseSelector = (s) => {
    const parsed = [];
    const selectors = s.split(',').map(s => s.trim());
    for (const s of selectors) {
        parsed.push(s.split(/\s+/));
    }
    return parsed;
};
const arraysEq = (a, b) => a.length === b.length && !a.some((aa, i) => aa !== b[i]);
const stackMatch = (
// the stack defined in the rule
ruleStack, 
// the actual stack
stack) => {
    if (!ruleStack.length)
        return true;
    let j = 0;
    for (const t of ruleStack) {
        if (t === stack[j]) {
            j++;
            if (j === ruleStack.length)
                return true;
        }
    }
    return false;
};
const filterRule = (stack, rule) => rule.filter(([ruleStack]) => stackMatch(ruleStack, stack));
// return style functions sorted in *ascending* order of priority
const getStyles = (stack, rule) => {
    const f = filterRule(stack, rule)
        .sort(([a], [b]) => a.length - b.length)
        .map(([_, r]) => r);
    return f.reduce((s, r) => {
        s.push(...r);
        return s;
    }, []);
};
const applyStyles = (content, tag, stack, t) => {
    const rule = t.get(tag);
    if (!rule)
        return content;
    const styles = getStyles(stack, rule);
    for (const style of styles) {
        content = style(content);
    }
    return content;
};
const trimTrailingCR = (c) => c.endsWith('\n') ? c.substring(0, c.length - 1) : c;
const blockStyle = (code, c, { minWidth = 0, maxWidth = process.stdout.columns || 80, padding = 1, lineNumbers = false, }) => {
    const lines = trimTrailingCR(code).split('\n');
    const lens = [];
    let max = minWidth;
    const npad = lineNumbers ? String(lines.length).length : 0;
    const tpad = npad + padding * 2;
    for (const l of lines) {
        const len = (0, string_length_1.default)(l);
        lens.push(len);
        if (len < maxWidth - tpad && len > max)
            max = len;
    }
    for (let i = 0; i < lens.length; i++) {
        const len = Number(lens[i]);
        const pad = max - len + padding;
        const r = pad > 0 ? ' '.repeat(pad) : '';
        const l = ' '.repeat(padding) +
            (lineNumbers
                ? applyStyles(String(i + 1).padStart(npad) + ' ', 'lineNumber', [], c)
                : '');
        lines[i] = l + lines[i] + r;
    }
    code = lines.join('\n') + '\n';
    return applyStyles(code, '_', [], c);
};
/**
 * Highlight the string of code provided, returning the string of highlighted
 * code.
 */
const highlight = (code, { language = 'tsx', theme = 'moria', minWidth, maxWidth, padding, lineNumbers, } = {}) => {
    const t = typeof theme === 'string' ? themes[theme] : theme;
    if (!t) {
        throw new Error('invalid theme: ' + theme);
    }
    const c = compileTheme(t);
    return blockStyle(stringify(prismjs_1.default.tokenize(code, prismjs_1.default.languages[language]), c), c, { minWidth, maxWidth, padding, lineNumbers });
};
exports.highlight = highlight;
const detectLanguage = (filename) => {
    const { ext } = (0, path_1.parse)(filename);
    switch (ext) {
        case '.ts':
        case '.mts':
        case '.cts':
            return 'typescript';
        case '.js':
        case '.cjs':
        case '.mjs':
            return 'javascript';
        case '.htm':
            return 'html';
        case '':
        case '.':
            throw new Error('could not detect language for file: ' + filename);
        default:
            // cross our fingers, I guess
            return ext.substring(1);
    }
};
/**
 * Read the filename provided, and highlight its code. If a language is not
 * provided in the opts, it will attempt to infer from the filename.
 */
const highlightFile = async (filename, opts = {}) => {
    if (!opts.language)
        opts.language = detectLanguage(filename);
    return (0, exports.highlight)(await (0, promises_1.readFile)(filename, 'utf8'), opts);
};
exports.highlightFile = highlightFile;
/**
 * Read the filename provided, and highlight its code. If a language is not
 * provided in the opts, it will attempt to infer from the filename.
 *
 * Synchronous {@link highlightFile}
 */
const highlightFileSync = (filename, opts = {}) => {
    if (!opts.language)
        opts.language = detectLanguage(filename);
    return (0, exports.highlight)((0, fs_1.readFileSync)(filename, 'utf8'), opts);
};
exports.highlightFileSync = highlightFileSync;
const stringify = (tok, theme, stack = []) => {
    if (typeof tok === 'string')
        return tok;
    if (Array.isArray(tok)) {
        return tok.map(t => stringify(t, theme, stack)).join('');
    }
    else {
        return applyStyles(stringify(tok.content, theme, [...stack, tok.type]), tok.type, stack, theme);
    }
};
const compiledThemes = new Map();
const compileTheme = (t) => {
    const pre = compiledThemes.get(t);
    if (pre)
        return pre;
    if (!(t instanceof Map)) {
        const c = compileTheme(new Map(Object.entries(t)));
        compiledThemes.set(t, c);
        return c;
    }
    const c = new Map();
    for (const [s, tr] of t.entries()) {
        const selectors = parseSelector(s);
        for (const sel of selectors) {
            // sel is a stack, so `x y z` becomes `['x', 'y', 'z']`
            // add the stack with the rule to the last item,
            // so we add [['x', 'y'], tr] to 'z'
            const last = sel[sel.length - 1];
            sel.pop();
            const cr = c.get(last) || [];
            let pushed = false;
            for (const [stack, rules] of cr) {
                if (arraysEq(sel, stack)) {
                    rules.push(...(Array.isArray(tr) ? tr : [tr]));
                    pushed = true;
                    break;
                }
            }
            if (!pushed)
                cr.push([sel, Array.isArray(tr) ? tr : [tr]]);
            if (!c.has(last))
                c.set(last, cr);
        }
    }
    const def = c.get('_');
    if (!def)
        c.set('_', [[[], [chalk_1.default.reset]]]);
    compiledThemes.set(t, c);
    return c;
};
const themes = __importStar(require("./themes/index.js"));
exports.themes = themes;
//# sourceMappingURL=index.js.map